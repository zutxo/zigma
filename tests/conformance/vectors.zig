//! JSON Test Vector Loader
//!
//! Loads conformance test vectors from JSON files for cross-implementation testing.
//! Vectors are generated by Scala sigmastate-interpreter and consumed by all implementations.
//!
//! Vector schema: ~/ergotree-research/conformance/vectors/schema.json

const std = @import("std");
const zigma = @import("zigma");
const hash = zigma.hash;
const verifier = zigma.verifier;
const sigma_tree = zigma.sigma_tree;
const SigmaBoolean = sigma_tree.SigmaBoolean;
const ProveDlog = sigma_tree.ProveDlog;
const ProveDHTuple = sigma_tree.ProveDHTuple;

// ============================================================================
// Vector Types
// ============================================================================

/// Version context for protocol-aware testing
pub const VersionContext = struct {
    block_version: u8,
    ergo_tree_version: u8,

    pub const v0 = VersionContext{ .block_version = 0, .ergo_tree_version = 0 };
    pub const v1 = VersionContext{ .block_version = 1, .ergo_tree_version = 1 };
    pub const v2 = VersionContext{ .block_version = 2, .ergo_tree_version = 2 };
    pub const v3 = VersionContext{ .block_version = 3, .ergo_tree_version = 3 };
};

/// Expected result of an evaluation
pub const ExpectedResult = union(enum) {
    /// Successful evaluation with typed value
    success: struct {
        type_name: []const u8,
        value_hex: []const u8,
        cost: ?u64,
    },
    /// Expected error
    err: struct {
        error_name: []const u8,
        cost: ?u64,
    },
};

/// Crypto operation test vector
pub const CryptoVector = struct {
    id: []const u8,
    description: []const u8,
    operation: CryptoOperation,
    inputs: CryptoInputs,
    expected: CryptoExpected,
    source_ref: []const u8,

    pub const CryptoOperation = enum {
        blake2b256,
        sha256,
        point_decode,
        point_encode,
        point_add,
        point_negate,
        point_multiply,
        verify_dlog,
        verify_dh_tuple,
        verify_and,
        verify_or,
        verify_threshold,
    };

    pub const CryptoInputs = struct {
        data: ?[]const u8 = null,
        message: ?[]const u8 = null,
        public_key: ?[]const u8 = null,
        public_key_1: ?[]const u8 = null,
        public_key_2: ?[]const u8 = null,
        signature: ?[]const u8 = null,
        dht_bytes: ?[]const u8 = null,
        point: ?[]const u8 = null,
        scalar: ?[]const u8 = null,
    };

    pub const CryptoExpected = union(enum) {
        hex: []const u8,
        boolean: bool,
        err: []const u8,
    };
};

/// Evaluation test vector (full ErgoTree evaluation)
pub const EvaluationVector = struct {
    id: []const u8,
    description: []const u8,
    ergotree_hex: []const u8,
    context: ?ContextData,
    version: ?VersionContext,
    expected: ExpectedResult,
    tags: []const []const u8,
    source_ref: []const u8,

    pub const ContextData = struct {
        height: u32,
        self_index: u32 = 0,
        // inputs, outputs, data_inputs populated from JSON
    };
};

/// Serialization test vector (roundtrip testing)
pub const SerializationVector = struct {
    id: []const u8,
    description: []const u8,
    type_name: []const u8,
    value_hex: []const u8,
    type_code_hex: ?[]const u8,
    source_ref: []const u8,
};

// ============================================================================
// Hardcoded Vectors (from Scala SigningSpecification.scala)
// ============================================================================

/// Hash function test vectors from CryptoFacadeSpecification.scala
pub const hash_vectors = [_]CryptoVector{
    .{
        .id = "blake2b256_empty",
        .description = "Blake2b256 hash of empty input",
        .operation = .blake2b256,
        .inputs = .{ .data = "" },
        .expected = .{ .hex = "0e5751c026e543b2e8ab2eb06099daa1d1e5df47778f7787faab45cdf12fe3a8" },
        .source_ref = "CryptoFacadeSpecification.scala",
    },
    .{
        .id = "blake2b256_abc",
        .description = "Blake2b256 hash of 'abc'",
        .operation = .blake2b256,
        .inputs = .{ .data = "616263" },
        .expected = .{ .hex = "bddd813c634239723171ef3fee98579b94964e3bb1cb3e427262c8c068d52319" },
        .source_ref = "CryptoFacadeSpecification.scala",
    },
    .{
        .id = "sha256_empty",
        .description = "SHA256 hash of empty input",
        .operation = .sha256,
        .inputs = .{ .data = "" },
        .expected = .{ .hex = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" },
        .source_ref = "CalcSha256Specification.scala",
    },
    .{
        .id = "sha256_abc",
        .description = "SHA256 hash of 'abc'",
        .operation = .sha256,
        .inputs = .{ .data = "616263" },
        .expected = .{ .hex = "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad" },
        .source_ref = "CalcSha256Specification.scala",
    },
};

/// Signature test vectors from SigningSpecification.scala
pub const signing_vectors = [_]CryptoVector{
    .{
        .id = "provedlog_basic",
        .description = "Simple ProveDlog signature verification",
        .operation = .verify_dlog,
        .inputs = .{
            .message = "1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00",
            .public_key = "03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1",
            .signature = "bcb866ba434d5c77869ddcbc3f09ddd62dd2d2539bf99076674d1ae0c32338ea95581fdc18a3b66789904938ac641eba1a66d234070207a2",
        },
        .expected = .{ .boolean = true },
        .source_ref = "SigningSpecification.scala:15-32",
    },
    .{
        .id = "provedht_basic",
        .description = "ProveDHTuple (Diffie-Hellman tuple) signature verification",
        .operation = .verify_dh_tuple,
        .inputs = .{
            .message = "1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00",
            .dht_bytes = "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817980280c66feee88d56e47bf3f47c4109d9218c60c373a472a0d9537507c7ee828c4802a96f19e97df31606183c1719400682d1d40b1ce50c9a1ed1b19845e2b1b551bf0255ac02191cb229891fb1b674ea9df7fc8426350131d821fc4a53f29c3b1cb21a",
            .signature = "eba93a69b28cfdea261e9ea8914fca9a0b3868d50ce68c94f32e875730f8ca361bd3783c5d3e25802e54f49bd4fb9fafe51f4e8aafbf9815",
        },
        .expected = .{ .boolean = true },
        .source_ref = "SigningSpecification.scala:35-44",
    },
    .{
        .id = "and_signature",
        .description = "AND (CAND) of two ProveDlog signatures",
        .operation = .verify_and,
        .inputs = .{
            .message = "1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00",
            .public_key_1 = "03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1",
            .public_key_2 = "0226abfc071cd6a44cf8457e48c8b17fca46f7b596b3dc70d7e5a7be3d9621f428",
            .signature = "9b2ebb226be42df67817e9c56541de061997c3ea84e7e72dbb69edb7318d7bb525f9c16ccb1adc0ede4700a046d0a4ab1e239245460c1ba45e5637f7a2d4cc4cc460e5895125be73a2ca16091db2dcf51d3028043c2b9340",
        },
        .expected = .{ .boolean = true },
        .source_ref = "SigningSpecification.scala:55-65",
    },
    .{
        .id = "or_signature",
        .description = "OR (COR) of two ProveDlog signatures",
        .operation = .verify_or,
        .inputs = .{
            .message = "1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00",
            .public_key_1 = "03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1",
            .public_key_2 = "0226abfc071cd6a44cf8457e48c8b17fca46f7b596b3dc70d7e5a7be3d9621f428",
            .signature = "ec94d2d5ef0e1e638237f53fd883c339f9771941f70020742a7dc85130aaee535c61321aa1e1367befb500256567b3e6f9c7a3720baa75ba6056305d7595748a93f23f9fc0eb9c1aaabc24acc4197030834d76d3c95ede60c5b59b4b306cd787d010e8217f34677d046646778877c669",
        },
        .expected = .{ .boolean = true },
        .source_ref = "SigningSpecification.scala:67-77",
    },
};

// ============================================================================
// Hex Utilities
// ============================================================================

/// Decode hex string to bytes (comptime or runtime)
pub fn hexToBytes(comptime hex: []const u8) [hex.len / 2]u8 {
    comptime {
        var result: [hex.len / 2]u8 = undefined;
        for (0..hex.len / 2) |i| {
            result[i] = hexDigit(hex[i * 2]) << 4 | hexDigit(hex[i * 2 + 1]);
        }
        return result;
    }
}

fn hexDigit(c: u8) u8 {
    return switch (c) {
        '0'...'9' => c - '0',
        'a'...'f' => c - 'a' + 10,
        'A'...'F' => c - 'A' + 10,
        else => 0,
    };
}

/// Convert bytes to hex string (runtime, allocating)
pub fn bytesToHex(allocator: std.mem.Allocator, bytes: []const u8) ![]u8 {
    const hex_chars = "0123456789abcdef";
    var result = try allocator.alloc(u8, bytes.len * 2);
    for (bytes, 0..) |b, i| {
        result[i * 2] = hex_chars[b >> 4];
        result[i * 2 + 1] = hex_chars[b & 0xf];
    }
    return result;
}

// ============================================================================
// Test Runner Helpers
// ============================================================================

/// Run hash conformance tests
pub fn runHashTests() !void {
    for (hash_vectors) |v| {
        switch (v.operation) {
            .blake2b256 => {
                const input = if (v.inputs.data) |d| hexToBytes(d) else [_]u8{};
                const result = hash.blake2b256(&input);
                const expected = hexToBytes(v.expected.hex);
                if (!std.mem.eql(u8, &result, &expected)) {
                    std.debug.print("FAIL: {s}\n", .{v.id});
                    return error.ConformanceFailure;
                }
            },
            .sha256 => {
                const input = if (v.inputs.data) |d| hexToBytes(d) else [_]u8{};
                const result = hash.sha256(&input);
                const expected = hexToBytes(v.expected.hex);
                if (!std.mem.eql(u8, &result, &expected)) {
                    std.debug.print("FAIL: {s}\n", .{v.id});
                    return error.ConformanceFailure;
                }
            },
            else => {},
        }
    }
}

// ============================================================================
// Tests
// ============================================================================

test "vectors: blake2b256 conformance" {
    // Empty input
    const empty_result = hash.blake2b256(&[_]u8{});
    const empty_expected = hexToBytes("0e5751c026e543b2e8ab2eb06099daa1d1e5df47778f7787faab45cdf12fe3a8");
    try std.testing.expectEqualSlices(u8, &empty_expected, &empty_result);

    // "abc"
    const abc_result = hash.blake2b256(&hexToBytes("616263"));
    const abc_expected = hexToBytes("bddd813c634239723171ef3fee98579b94964e3bb1cb3e427262c8c068d52319");
    try std.testing.expectEqualSlices(u8, &abc_expected, &abc_result);
}

test "vectors: sha256 conformance" {
    // Empty input
    const empty_result = hash.sha256(&[_]u8{});
    const empty_expected = hexToBytes("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855");
    try std.testing.expectEqualSlices(u8, &empty_expected, &empty_result);

    // "abc"
    const abc_result = hash.sha256(&hexToBytes("616263"));
    const abc_expected = hexToBytes("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad");
    try std.testing.expectEqualSlices(u8, &abc_expected, &abc_result);
}

test "vectors: hexToBytes comptime" {
    const result = hexToBytes("deadbeef");
    try std.testing.expectEqualSlices(u8, &[_]u8{ 0xde, 0xad, 0xbe, 0xef }, &result);
}

test "vectors: empty hex" {
    const result = hexToBytes("");
    try std.testing.expectEqual(@as(usize, 0), result.len);
}

// ============================================================================
// Sigma Protocol Verification Conformance Tests
// Reference: SigningSpecification.scala from sigmastate-interpreter
// ============================================================================

test "conformance: ProveDlog signature verification" {
    // From SigningSpecification.scala:15-32
    // secret: BigInt("109749205800194830127901595352600384558037183218698112947062497909408298157746")
    // public key derived from secret
    const message = hexToBytes("1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00");
    const pk_bytes = hexToBytes("03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1");
    const signature = hexToBytes("bcb866ba434d5c77869ddcbc3f09ddd62dd2d2539bf99076674d1ae0c32338ea95581fdc18a3b66789904938ac641eba1a66d234070207a2");

    // Create ProveDlog proposition
    const prop = SigmaBoolean{ .prove_dlog = ProveDlog.init(pk_bytes) };

    // Verify signature
    const is_valid = verifier.verifySignature(prop, &signature, &message) catch |err| {
        std.debug.print("Verification error: {s}\n", .{@errorName(err)});
        return err;
    };

    try std.testing.expect(is_valid);
}

test "conformance: ProveDHTuple signature verification" {
    // From SigningSpecification.scala:35-44
    // DHT: (g, h, u, v) where g is generator, secret x, h = g^y, u = g^x, v = h^x
    const message = hexToBytes("1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00");

    // DHT bytes: g || h || u || v (4 * 33 = 132 bytes)
    const dht_bytes = hexToBytes("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f817980280c66feee88d56e47bf3f47c4109d9218c60c373a472a0d9537507c7ee828c4802a96f19e97df31606183c1719400682d1d40b1ce50c9a1ed1b19845e2b1b551bf0255ac02191cb229891fb1b674ea9df7fc8426350131d821fc4a53f29c3b1cb21a");
    const signature = hexToBytes("eba93a69b28cfdea261e9ea8914fca9a0b3868d50ce68c94f32e875730f8ca361bd3783c5d3e25802e54f49bd4fb9fafe51f4e8aafbf9815");

    // Parse DHT: g(33) || h(33) || u(33) || v(33)
    const g = dht_bytes[0..33];
    const h = dht_bytes[33..66];
    const u = dht_bytes[66..99];
    const v = dht_bytes[99..132];

    // Create ProveDHTuple proposition
    const prop = SigmaBoolean{
        .prove_dh_tuple = ProveDHTuple{
            .g = g.*,
            .h = h.*,
            .u = u.*,
            .v = v.*,
        },
    };

    // Verify signature
    const is_valid = verifier.verifySignature(prop, &signature, &message) catch |err| {
        std.debug.print("DHT Verification error: {s}\n", .{@errorName(err)});
        return err;
    };

    try std.testing.expect(is_valid);
}

test "conformance: AND signature verification" {
    // From SigningSpecification.scala:55-65
    // AND of two ProveDlog propositions
    const message = hexToBytes("1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00");
    const pk1_bytes = hexToBytes("03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1");
    const pk2_bytes = hexToBytes("0226abfc071cd6a44cf8457e48c8b17fca46f7b596b3dc70d7e5a7be3d9621f428");
    const signature = hexToBytes("9b2ebb226be42df67817e9c56541de061997c3ea84e7e72dbb69edb7318d7bb525f9c16ccb1adc0ede4700a046d0a4ab1e239245460c1ba45e5637f7a2d4cc4cc460e5895125be73a2ca16091db2dcf51d3028043c2b9340");

    // Create AND(pk1, pk2) proposition
    const child1 = SigmaBoolean{ .prove_dlog = ProveDlog.init(pk1_bytes) };
    const child2 = SigmaBoolean{ .prove_dlog = ProveDlog.init(pk2_bytes) };
    const children = [_]*const SigmaBoolean{ &child1, &child2 };
    const prop = SigmaBoolean{ .cand = .{ .children = &children } };

    // Verify signature
    const is_valid = verifier.verifySignature(prop, &signature, &message) catch |err| {
        std.debug.print("AND Verification error: {s}\n", .{@errorName(err)});
        return err;
    };

    try std.testing.expect(is_valid);
}

test "conformance: OR signature verification" {
    // From SigningSpecification.scala:67-77
    // OR of two ProveDlog propositions (only one secret known)
    const message = hexToBytes("1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00");
    const pk1_bytes = hexToBytes("03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1");
    const pk2_bytes = hexToBytes("0226abfc071cd6a44cf8457e48c8b17fca46f7b596b3dc70d7e5a7be3d9621f428");
    const signature = hexToBytes("ec94d2d5ef0e1e638237f53fd883c339f9771941f70020742a7dc85130aaee535c61321aa1e1367befb500256567b3e6f9c7a3720baa75ba6056305d7595748a93f23f9fc0eb9c1aaabc24acc4197030834d76d3c95ede60c5b59b4b306cd787d010e8217f34677d046646778877c669");

    // Create OR(pk1, pk2) proposition
    const child1 = SigmaBoolean{ .prove_dlog = ProveDlog.init(pk1_bytes) };
    const child2 = SigmaBoolean{ .prove_dlog = ProveDlog.init(pk2_bytes) };
    const children = [_]*const SigmaBoolean{ &child1, &child2 };
    const prop = SigmaBoolean{ .cor = .{ .children = &children } };

    // Verify signature
    const is_valid = verifier.verifySignature(prop, &signature, &message) catch |err| {
        std.debug.print("OR Verification error: {s}\n", .{@errorName(err)});
        return err;
    };

    try std.testing.expect(is_valid);
}

test "conformance: ProveDlog wrong message fails" {
    // Same signature as provedlog_basic but different message
    const wrong_message = hexToBytes("0000000000000000000000000000000000000000000000000000000000000000");
    const pk_bytes = hexToBytes("03cb0d49e4eae7e57059a3da8ac52626d26fc11330af8fb093fa597d8b93deb7b1");
    const signature = hexToBytes("bcb866ba434d5c77869ddcbc3f09ddd62dd2d2539bf99076674d1ae0c32338ea95581fdc18a3b66789904938ac641eba1a66d234070207a2");

    const prop = SigmaBoolean{ .prove_dlog = ProveDlog.init(pk_bytes) };

    const is_valid = verifier.verifySignature(prop, &signature, &wrong_message) catch |err| {
        std.debug.print("Expected failure verification error: {s}\n", .{@errorName(err)});
        return err;
    };

    // Should fail with wrong message
    try std.testing.expect(!is_valid);
}

test "conformance: ProveDlog wrong public key fails" {
    // Correct message and signature but wrong public key
    const message = hexToBytes("1dc01772ee0171f5f614c673e3c7fa1107a8cf727bdf5a6dadb379e93c0d1d00");
    const wrong_pk = hexToBytes("0226abfc071cd6a44cf8457e48c8b17fca46f7b596b3dc70d7e5a7be3d9621f428"); // pk2 instead of pk1
    const signature = hexToBytes("bcb866ba434d5c77869ddcbc3f09ddd62dd2d2539bf99076674d1ae0c32338ea95581fdc18a3b66789904938ac641eba1a66d234070207a2");

    const prop = SigmaBoolean{ .prove_dlog = ProveDlog.init(wrong_pk) };

    const is_valid = verifier.verifySignature(prop, &signature, &message) catch |err| {
        std.debug.print("Expected failure verification error: {s}\n", .{@errorName(err)});
        return err;
    };

    // Should fail with wrong public key
    try std.testing.expect(!is_valid);
}
